\chapter{Aktuelle Probleme der Frontend-Webentwicklung}
\label{cha:frontend-problems}

Das größte Problem der Frontend-Webentwicklung wird in \autocite{Kirejczyk.HDD:online} \emph{Hype Driven Development} genannt.
Damit ist die enorm hohe Frequenz gemeint, in der neue Technologien entstehen, hochgepriesen werden und danach genau so schnell wieder von neueren abgelöst und verdrängt werden.

Gerade im Web-Bereich ist durch den Trend zu Open Source Software eine sehr hohe Obsoleszenz zu beobachten, da durch das abzweigen (engl. \emph{forken}) verschiedene Varianten von gesamten Projekten entstehen.
Dem dadurch entstehenden schnellen Fortschritt steht allerdings die Spaltung von Entwicklergemeinschaften und inkompatible Technologien gegenüber.

Ein Beispiel dafür ist die Teilung von Node.js\footnote{\url{https://nodejs.org/}} in die zwei Projekte Node.js und io.js\footnote{\url{https://iojs.org/}} im Jahr 2014, die allerdings aus den vorhin beschriebenen Problemen 2015 wieder zu Node.js vereint wurden \autocite{Node.io-node-merge:online}.
Kurzlebige, innovative Technologien bringen die Softwareentwicklung im Generellen voran, doch um eine Technologie in seriösen Anwendungen verwenden zu können, ist ein gewisser Reifegrad notwendig.
Dieser ermöglicht nicht nur stabile Versionen und besser ausgebildete Entwickler, durch einen Einzug der Technologie in die Lehre, sondern vor allem durchdachte und ausgereifte Werkzeuge für Entwickler.

Nach erfolgreicher Auswahl eines Frameworks ist in der Frontend-Entwicklung die größte Hürde die Konfiguration der benötigten Werkzeuge.
Die Schwierigkeit liegt wiederum in der beinahe täglichen Aktualisierung der Werkzeuge, die teilweise inkompatible Änderungen verursachen und dem ständigen Erscheinen neuer Werkzeuge.
Hilfsanwendungen wie create-react-app\footnote{\url{https://github.com/facebookincubator/create-react-app}} oder Angular CLI\footnote{\url{https://github.com/angular/angular-cli}} erleichtern die Erstellung von Webanwendungen, indem sie ein initiales Projekt konfigurieren, in dem bereits alle benötigten Abhängigkeiten und Werkzeuge integriert sind.

Im Folgenden werden einige der Werkzeuge beschrieben, um einerseits deren Schnellebigkeit zu veranschaulichen und andererseits einen Überblick zu liefern, welche Werkzeuge wozu aktuell eingesetzt werden.

\section{Werkzeugübersicht}
\label{sec:tools-overview}

\subsection{JavaScript-Modulsysteme}
\label{sub:js-modulesystems}
% https://auth0.com/blog/javascript-module-systems-showdown/
\subsubsection{CommonJS}
\label{sub:commonjs}
\subsubsection{AMD}
\label{sub:amd}
\subsubsection{ES2015}
\label{sub:es2015}


\subsection{Paketmanager}
\label{sub:package-managers}

Lokale vs. Globale Installation
Angular CLI

% http://andrewhfarmer.com/javascript-frontend-package-managers/

\subsubsection{npm}
\label{sub:npm}
\subsubsection{bower}
\label{sub:bower}
% https://gofore.com/stop-using-bower/
% https://shellmonger.com/2015/07/26/moving-from-bower-to-npm/
% https://www.quora.com/Why-use-Bower-when-there-is-npm
% https://stackoverflow.com/questions/18641899/what-is-the-difference-between-bower-and-npm
\subsubsection{yarn}
\label{sub:yarn}
\subsubsection{jspm}
\label{sub:jspm}
\subsubsection{Duo}
\label{sub:duo}



\subsection{Build-Werkzeuge}
\label{sub:build-tools}

% http://ericlathrop.com/2017/05/the-problem-with-npm-install-global/

\subsubsection{grunt}
\label{sub:grunt}
\subsubsection{gulp}
\label{sub:gulp}
\subsubsection{webpack}
\label{sub:webpack}
\subsubsection{rollup}
\label{sub:rollup}
% https://medium.com/webpack/webpack-and-rollup-the-same-but-different-a41ad427058c
\subsubsection{Best Practice}
\label{sub:build-tools-best-practices}


\section{Inkompatible node/npm-Versionen}
Die Basis für die meisten Werkzeuge in der Frontend-Webentwicklung bildet \emph{Node.js}.
Node.js ist eine Laufzeitumgebung, die auf der Chrome-V8-JavaScipt-Engine basiert und es ermöglicht JavaScript ohne Browser auf dem System nativ auszuführen.
Der große Vorteil, der vor allem Entwicklerwerkzeuge betrifft, ist die Plattformunabhängigkeit.
Dadurch können Kommandozeilenwerkzeuge mithilfe von Webtechnologien für alle gängigen Betriebssysteme erstellt werden.

\emph{npm} ist ein Paketmanager, der es ermöglicht Node.js-Anwendungen zu installieren, oder Abhängigkeiten zwischen Paketen zu spezifizieren.

Wie in \autocite{Papa.n:online} beschrieben, kann es nun allerdings sein, dass bestimmte Werkzeuge unter bestimmten Node.js-Versionen nicht funktionieren.
Auch das Testen der Anwendung unter verschiedenen Node.js-Versionen gestaltet sich schwierig, da dafür jedesmal eine Neuinstallation notwwendig wäre.
Ein weiteres Problem ist, dass die benötigte Node.js-Version bei Projekten nicht mitversioniert werden kann.
Sie kann maximal in einer Readme-Datei erfasst werden, wobei von jedem Entwickler sichergestellt werden muss, dass er die korrekte Version verwendet.
Bei der Entwicklung mehrerer Projekte wird dieses Problem allerdings noch ersichtlicher.


\section{Parallele Entwicklung mehrerer Projekte}
Wie in \cref{sec:softaware} erläutert, ist es in der Firma softaware gmbh üblich, dass ein Entwickler an mehreren Projekten gleichzeitig arbeitet.
Dadurch wird das vorhin erwähnte Problem noch deutlicher sichtbar, da es nun vorkommen kann, dass bei der Entwicklung unterschiedlicher Projekte auf unterschiedliche Node.js-Versionen gewechselt werden muss.

Ein Lösungsansatz ist die Verwendung von Vagrant. 
Vagrant ist ein Werkzeug zur automatischen Verwaltung von virtuellen Maschinen und verfolgt den Ansatz, dass die Entwicklung in einer virtuellen Maschine stattfindet.
Eine virtuelle Maschine benötigt erhebliche Ressourcen, wenn keine grafische Oberfläche benötigt wird, ist dieser Ansatz nur schwer zu rechtfertigen.

Ein weiterer Ansatz ist die Verwendung von sogenannten Node.js-Versionsmanagern.
Beispiele dafür sind nvm\footnote{\url{https://github.com/creationix/nvm}}, n\footnote{\url{https://github.com/tj/n}} oder nvm-windows\footnote{\url{https://github.com/coreybutler/nvm-windows}}.
Das Hauptproblem dabei ist allerdings, dass es keine Lösung gibt, die plattformübergreifend funktioniert.
Außerdem wurde die Entwicklung des als letztes erwähnten nvm-windows eingestellt.
Ein weiteres Problem ist die fehlende Integration in das Projekt.
Diese Werkzeuge werden als eigenständige Anwendung auf dem Entwicklerrechner installiert und stellen eine implizite Abhängigkeit des Projektes dar.

Nicht nur die parallele Entwicklung mehrerer Projekte kann Probleme bereiten.
In der Firma softaware gmbh kommt es außerdem regelmäßig vor, dass andere Unternehmen als Projektpartner fungieren.
Gerade in diesem Fall ist es wichtig, eine einheitliche Lösung zur Verwaltung von Node.js-Versionen zu finden, da für diese Projektpartner die Hemmschwelle zur Entwicklung möglichst niedrig sein soll.


\section{Globale Installation von npm-Paketen}
Bei der vorhin erwähnten Installation von npm-Paketen existieren zwei Möglichkeiten.

Für diverse Werkzeuge (\zB gulp\footnote{\url{http://gulpjs.com/}}) wird als Installationskommando \texttt{npm install -g <werkzeug>} vorgeschlagen, wobei das Paket durch den Parameter \emph{\texttt{-p}} global installiert wird.
Diese Art der Installation bedeutet, dass diese Anwendungen mit ihrem jeweiligen Namen von der Kommandozeile gestartet werden können.

Die zweite Möglichkeit der Installation ist das Weglassen des Parameters \texttt{-p}, wodurch das Paket in der Manifest-Datei \texttt{package.json} des Projekts erfasst und in einen Ordner namens \texttt{node\char`_modules} im aktuellen Verzeichnis installiert wird.
Da dieses Paket nun als Abhängigkeit deklarativ erfasst ist, lässt es sich mit dem Projekt versionieren und wird bei der Installation dessen auf einem anderen Entwicklergerät automatisch mitinstalliert.

TODO:
* globale Installation (ng create, gulp, ...), was zwar die lokal installierte Kopie forwarded, jedoch, falls im Readme erwähnt, auf anderen Rechnern ebenso eine globale Installation benötigt, damit das Kommando ausgeführt werden kann, in Legacy-Projekten oft nur schwer änderbar + Sicherheitsrisiko
% - https://stackoverflow.com/questions/9679932/how-to-use-package-installed-locally-in-node-modules#comment33532258_9683472


\section{Legacy-Anwendungen}
\label{sec:legacy-applications}
